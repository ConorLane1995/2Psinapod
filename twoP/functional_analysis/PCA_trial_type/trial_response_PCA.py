"""
Plots the projection of individual trials onto the first 3 PCA axes. 
Uses the average value of each trial response as the sample feature to input to the PCA.
INPUT: conditions .mat file, cell_dict
AUTHOR: Veronica Tarka, July 2022, veronica.tarka@mail.mcgill.ca
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from matplotlib.lines import Line2D
from scipy.io import loadmat
import seaborn as sns
import pickle
import json
import sys
import os

# more info: https://pietromarchesi.net/pca-neural-data.html

sys.path.append(os.path.abspath(os.path.dirname(__file__)) + '/../../')
from utils import get_active_cells

# load what we need from the config file
with open(os.path.abspath(os.path.dirname(__file__)) +'/../../../config.json','r') as f:
    config = json.load(f)

BASE_PATH = config['RecordingFolder'] # folder with all of the files generated by Suite2P for this recording (F.npy, iscell.npy, etc)
CONDITIONS_PATH = config['Conditions'] # name of the CSV (assumed to be within BASE_PATH) with the condition types of each trial (freq, intensity, etc)
CELL_DICT = config['AnalysisFile'] # name of the file that all of the analysis is getting saved in (tuning, best frequency, etc)

ACTIVE_CELLS_ONLY = False
N_BASELINE_FRAMES = 4

"""
Function to standardize the data so it can be used in the PCA
@param data: n_features x n_samples
@param data_c: normalized data
"""
def standardize(data):
    # data: n_features x n_samples

    ss = StandardScaler(with_mean=True,with_std=True)
    data_c = ss.fit_transform(data.T).T
    return data_c

""" 
Formats the plots in main()
Author credit: https://pietromarchesi.net/pca-neural-data.html
"""
def add_orientation_legend(ax,trial_types):
    pal = sns.color_palette('rocket_r', 13)
    custom_lines = [Line2D([0], [0], color=pal[k], lw=4) for
                    k in range(len(trial_types))]
    labels = ['{}'.format(t) for t in trial_types]
    ax.legend(custom_lines, labels,
              frameon=False, loc='center left', bbox_to_anchor=(1, 0.5))
    plt.tight_layout(rect=[0,0,0.9,1])


def main():
    data = np.load(BASE_PATH+"epoched_traces.npy")
    conditions_mat = loadmat(BASE_PATH+CONDITIONS_PATH) # conditition type of each trial in chronological order (row 1 = trial 1)
    conditions = conditions_mat["stim_data"]

    if ACTIVE_CELLS_ONLY:
        with open(BASE_PATH+CELL_DICT,"rb") as f:
            cell_dict = pickle.load(f)

        active_cell_dict = get_active_cells(cell_dict)
        active_cell_IDs = np.array(list(active_cell_dict.keys()))
        all_IDs = np.array(list(cell_dict.keys()))
        active_cell_idx = np.nonzero(np.in1d(all_IDs,active_cell_IDs))[0]

        epoched_data = data[active_cell_idx,:,:]
    else:
        epoched_data = data

    # trials is a list of K Numpy arrays of shape NÃ—T (number of neurons by number of time points)
    trials = []
    for trial_idx in range(len(epoched_data[0])):
        trials.append(epoched_data[:,trial_idx,:])

    trial_type = conditions[:,0] # list of length K containing the type (i.e. frequency) of every trial

    trial_types = np.unique(conditions[:,0]) # list containing the unique trial types (i.e. frequencies) in ascending order

    # take the mean value across all frames in a single trial (so you get one value per trial and stack all the trials)
    Xr = np.vstack([t[:,N_BASELINE_FRAMES:].mean(axis=1) for t in trials]).T
    Xr_sc = standardize(Xr) # standardize

    pca = PCA(n_components=15) # get the first 15 components of the PCA
    Xp = pca.fit_transform(Xr_sc.T).T # apply the PCA
    
    # Reverse the trial types list so it looks right on the graph
    trial_types = list(reversed(trial_types))

    pal = sns.color_palette('rocket_r', len(trial_types))
    projections = [(0, 1), (1, 2), (0, 2)] # take the PCA components we want to plot on x and y
    fig, axes = plt.subplots(1, 3, figsize=[9, 3], sharey='row', sharex='row')
    for ax, proj in zip(axes, projections):
        for t, t_type in enumerate(trial_types):
            x = Xp[proj[0], np.nonzero(trial_type==t_type)]
            y = Xp[proj[1], np.nonzero(trial_type==t_type)]
            ax.scatter(x, y, c=pal[t], s=30, alpha=0.7)
            ax.set_xlabel('PC {}'.format(proj[0]+1))
            ax.set_ylabel('PC {}'.format(proj[1]+1))

    sns.despine(fig=fig, top=True, right=True)

    add_orientation_legend(axes[2],trial_types)
    plt.show()


if __name__=="__main__":
    main()