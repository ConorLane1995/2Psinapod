"""
Script to find sound-responsive cells by evaluating the peak of the average response to the highest intensity stimuli.
INPUT: Dictionary with the epoched traces
OUTPUT: Same dictionary but now with an added key "active" that holds a boolean
AUTHOR: Veronica Tarka, January 2022, veronica.tarka@mail.mcgill.ca
"""

import numpy as np
import pickle
import json
import os

# load what we need from the config file
with open(os.path.abspath(os.path.dirname(__file__)) +'/../../config.json','r') as f:
    config = json.load(f)

BASE_PATH = config['RecordingFolder'] # folder with all of the files generated by Suite2P for this recording (F.npy, iscell.npy, etc)
TRACES_FILE = config['AnalysisFile']
OUTPUT_FILE = TRACES_FILE
FRAMERATE = config['RecordingFR']
EPOCH_START_IN_MS = config['EpochStart']

STD_THRESHOLD = 3 # number of standard deviations from baseline the peak response must be in order for the cell to be considered active
ZSCORE_THRESHOLD = 2 # number of zscores from the mean that the peak response must be from baseline in order for the cell to be considered active

"""
Get the cell's average response to stimuli at the highest intensity
@param cell_trace: a single cell's trial activity (the contents of 'traces' in the big dictionary)
@return the trial average across all trials at the highest intensity
"""
def get_high_intensity_avg(cell_trace):

    # first we need to find how much space to allocate
    n_samples = 0
    n_trials = 0
    for freq in cell_trace:
        highest_intensity = list(cell_trace[freq])[-1]
        for repetition in cell_trace[freq][highest_intensity]:
            if n_trials == 0:
                n_samples = len(cell_trace[freq][highest_intensity][repetition])
            n_trials += 1
              
    summed_traces = np.zeros(shape=(n_trials,n_samples))

    counter = 0
    # let's get a sum of all our traces to average later
    for freq in cell_trace:
        highest_intensity = list(cell_trace[freq])[-1]
        for repetition in cell_trace[freq][highest_intensity]:
            trace = cell_trace[freq][highest_intensity][repetition]
            summed_traces[counter,:] = trace
            counter += 1

    return np.average(summed_traces,axis=0)

"""
Check whether a cell is responsive based on number of STDs the peak is from baseline DURING TRIALS WITH THE HIGHEST INTENSITY ONLY
@param cell_trace: a single cell's trial activity (the contents of 'traces' in the big dictionary)
@param n_baseline_frames: the number of frames included in the trial epoch that preced the stimulus onset
@return T/F: true if the cell's peak response was sufficient STD from the baseline distribution
"""
def check_cell_STD(cell_trace,n_baseline_frames):

    this_cell_trace = get_high_intensity_avg(cell_trace)

    # get the baseline for this trial
    baseline = this_cell_trace[0:n_baseline_frames]
    response = this_cell_trace[n_baseline_frames:]

    # get our threshold
    peak_threshold = np.mean(baseline) + STD_THRESHOLD*np.std(baseline)

    # get the peak response
    peak_response = np.amax(response)

    # get the index of the peak response
    peak_response_idx = np.argmax(response)

    # if our peak response was above our threshold, increase the counter
    if (peak_response >= peak_threshold) and (peak_response_idx < 10):
        return True
    else:
        return False

"""
Check if a cell is responsive based on number of z-scores the peak is from baseline ONLY AT THE HIGHEST INTENSITIES
@param cell_trace: a single cell's trial activity (the contents of 'traces' in the big dictionary)
@return T/F: true if the cell's peak response was sufficiently large z-score
"""
def check_cell_zscore(cell_trace,n_baseline_frames):

    # get our average trace
    avg_trace = get_high_intensity_avg(cell_trace)

    baseline = avg_trace[0:n_baseline_frames]
    baseline_mean = np.average(baseline)
    baseline_std = np.std(baseline)

    if baseline_std!=0:
        zscorer = lambda x: (x-baseline_mean)/baseline_std
    else:
        zscorer = lambda x: x

    response = avg_trace[n_baseline_frames:]
    zscore_response = np.array([zscorer(xi) for xi in response])

    # get the peak of the response
    peak_response = np.amax(zscore_response)

    # get the index of the peak response
    peak_response_idx = np.argmax(zscore_response)

    if (peak_response > ZSCORE_THRESHOLD) and (peak_response_idx < 10):
        return True
    else:
        return False
    
"""
Iterate through each cell and check whether it is sound responsive using either the STD method or z-score method
@param cell_dictionary: dictionary of cells with trace activity stored in key "traces" in each cell
@param n_baseline_frames: the number of frames included in the trial epoch that preced the stimulus onset
@return cell_dictionary: same dictionary as was input except with new key 'active' that contains T/F for whether the cell was responsive or not
""" 
def check_all_cells(cell_dictionary,n_baseline_frames):
    
    for cell in cell_dictionary:
        if (check_cell_STD(cell_dictionary[cell]['traces'],n_baseline_frames)):
            cell_dictionary[cell]['active'] = True
        else:
            cell_dictionary[cell]['active'] = False

    return cell_dictionary

def main():
    
    # import our cell dictionary
    # it's formatted like this: 
    # cell { 'traces' { freq { intensity { repetition: [x,x,x,x,...] }}}}
    with open(BASE_PATH + TRACES_FILE, 'rb') as f:
        cell_dictionary = pickle.load(f)

    # define our pre-stim baseline we'll pass into our functions
    n_baseline_frames = round(EPOCH_START_IN_MS/1000 * FRAMERATE) * -1 # these are the frames we'll use as the baseline
    
    traces_with_active_boolean = check_all_cells(cell_dictionary,n_baseline_frames)

    # find the number of active cells
    counter = 0
    for cell in traces_with_active_boolean:
        if traces_with_active_boolean[cell]['active'] == True:
            counter += 1

    print("Number of total cells: ")
    print(len(cell_dictionary))
    print("Number of active cells: ")
    print(counter)

    with open(BASE_PATH+OUTPUT_FILE,'wb') as f:
        pickle.dump(traces_with_active_boolean,f)

if __name__=='__main__':
    main()