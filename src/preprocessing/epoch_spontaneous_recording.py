"""
Script to take the files produced from the Suite2P preprocessing software and epoch the recording into trials.
INPUT: stim triggers in csv, Suite2P files (F.npy, Fneu.npy, iscell.npy)
OUTPUT: epoched_F.npy formatted as nCells x nTrials x nFrames array
AUTHOR: Veronica Tarka, January 2022, veronica.tarka@mail.mcgill.ca
"""

import matplotlib as mpl
import matplotlib.pyplot as plt
from itertools import compress
import scipy.io as scio
import numpy as np
import os
import pickle
import json
import math


# load what we need from the config file
with open(os.path.abspath(os.path.dirname(__file__)) +'/../../config.json','r') as f:
    config = json.load(f)

BASE_PATH = config['RecordingFolder'] # folder with all of the files generated by Suite2P for this recording (F.npy, iscell.npy, etc)
csv_path = config['Triggers'] # name of CSV (assumed to be in the folder given in line above) with the trigger voltages over the recording
conditions_path = config['Conditions'] # name of the CSV (assumed to be in folder given two lines above) with the condition types of each trial (freq, intensity, etc)
output_path = config['AnalysisFile'] # name of the file that all of the analysis is getting saved in (tuning, best frequency, etc)
STIMULUS_FRAMERATE = config['TriggerFR']
TRIGGER_DELAY_IN_MS = config['TriggerDelay'] # delay between TDT sending a trigger and the stimulus actually happening
RECORDING_FRAMERATE = config['RecordingFR']


def format_trials(traces,stim):

    # traces should be an nTrial x nFrame array of the dF/F over each trial
    # stim should be an nTrial x 4 array (info on this structure in the README.md)

    # this will return a dictionary that will be contained within this cell key in the big dictionary

    # format the dictionary so we get this structure:
    # cell_ID{
    #     traces{ 
    #        freq_f{
    #           intensity_i{
    #                repetition{ 
    #                       1 = [x,x,x,x,...]
    #                           }
    #                   }
    #            }
    #       }
    # }

    # use the frequencies we played as the keys of our dictionary (outermost dictionary)
    freq_dict = dict.fromkeys(np.unique(stim[:,0]))

    # nest each intensity the frequencies were presented at inside our freq dictionary
    for freq in freq_dict:
        freq_dict[freq] = dict.fromkeys(np.unique(stim[:,1]))

    # make empty dictionaries so we can index properly later
    for freq in freq_dict:
        for intensity in freq_dict[freq]:
            freq_dict[freq][intensity] = {}

    # make a temporary map so we can keep track of how many repetitions of this trial we've seen
    # just going to add together the frequency and intensity to index it
    # biggest element we'll need is max(frequency) + max(intensity)
    max_element = max(stim[:,0]) + max(stim[:,1]) + 10
    temp_map = [0] * max_element

    # for each trial
    for trial in range(len(stim)):

        # trial's frequency
        f = stim[trial,0]

        # trial's intensity
        i = stim[trial,1]

        # access the map to see how many repetitions of the frequency and intensity we've already seen
        # this way we don't overwrite a trial with the same stimulus type
        num_rep = temp_map[f+i]+1
        temp_map[f+i] += 1

        # using the frequency and intensity to index our dictionary to store our trace
        freq_dict[f][i][num_rep] = traces[trial,:]

    return freq_dict

def format_all_cells(epoched_traces,iscell_logical):
    # epoched traces is an nCells x nTrials x nFramesPerTrial array
    # stim should be an nTrial x 4 array (info on this structure in the README.md)
    # iscell_logical is an nCells x 1 array of whether or not each ROI is a cell

    # make a dictionary where each cell is one key

    # find the label for each ROI by finding this indices where iscell_logical is 1
    ROI_indices = (iscell_logical[:,0] == 1).nonzero()
    ROI_indices = ROI_indices[0] # extracting the first part of the tuple
    cell_IDs = ROI_indices + 1 # add 1 so we don't have zero indexing

    # make a dictionary from this list
    dict_of_cells = dict.fromkeys(cell_IDs)

    # for each cell
    # format the dictionary so we get this structure:
    # cell_n{ 
    #     freq_f{
    #           intensity_i{
    #                     repetition{
    #                           trace = [x,x,x,x,...]
    #                       }
    #            }
    # }

    for cell_idx in range(len(cell_IDs)):
        dict_of_cells[cell_IDs[cell_idx]] = {'traces': epoched_traces[cell_idx,:]}
    
    return dict_of_cells

def plot_trace(fl,onsets):
    for i in range(len(fl)):
        plt.plot(fl[i,:]) #,label=i)

    # plt.legend(loc="upper left")
    plt.vlines(onsets,0,1000,linewidth=2)
    plt.show()


def main():

    # load our files that were generated by Suite2P and the stim files
    fluorescence_trace = np.load(BASE_PATH + "F.npy",allow_pickle=True) # uncorrected trace of dF/F
    neuropil_trace = np.load(BASE_PATH + "Fneu.npy",allow_pickle=True) # estimation of background fluorescence
    iscell_logical = np.load(BASE_PATH + "iscell.npy",allow_pickle=True) # Suite2P's estimation of whether each ROI is a cell or not

    # account for the neuropil (background fluorescence)
    corrected_fluo = fluorescence_trace - 0.7*neuropil_trace
    
    # get fluorescence traces for the ROIs that are actually cells
    fluo_in_cells = corrected_fluo[np.where(iscell_logical[:,0]==1)[0],:]


    dictionary_of_cells = format_all_cells(fluo_in_cells,iscell_logical)

    # save to the provided output path
    with open(BASE_PATH+output_path,'wb') as f:
        pickle.dump(dictionary_of_cells,f)

if __name__=='__main__':
    main()