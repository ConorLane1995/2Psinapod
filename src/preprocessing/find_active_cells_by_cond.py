"""
Script to find sound-responsive cells by evaluating the median trial response to each condition. 
If any single condition type elicits a response that is above the threshold, the cell is considered responsive.
INPUT: Dictionary with the epoched traces
OUTPUT: Same dictionary but now with an added key "active" that holds a boolean (T if the cell is responsive)
AUTHOR: Veronica Tarka, January 2022, veronica.tarka@mail.mcgill.ca
"""

import numpy as np
import pickle
import json
import os

# load what we need from the config file
with open(os.path.abspath(os.path.dirname(__file__)) +'/../../config.json','r') as f:
    config = json.load(f)

BASE_PATH = config['RecordingFolder'] # folder with all of the files generated by Suite2P for this recording (F.npy, iscell.npy, etc)
TRACES_FILE = config['AnalysisFile']
OUTPUT_FILE = TRACES_FILE
FRAMERATE = config['RecordingFR']
EPOCH_START_IN_MS = config['EpochStart']

ZSCORE_THRESHOLD = 3 # number of zscores from the mean that the peak response must be from baseline in order for the cell to be considered active

"""
Redefine trial activity as z-scores relative to the baseline frames immediately preceding the stimulus
@param trial: nFrames x 1 vector of dF/F values over the trial
@param n_baseline_frames: the number of frames included in the trial epoch which preceded the stimulus
@return zscore_response: the frames occuring after the stimulus onset now defined as z-scores relative to pre-stim baseline
"""
def get_zscored_response(trial,n_baseline_frames):
    baseline = trial[:n_baseline_frames]
    response = trial[n_baseline_frames:]

    baseline_mean = np.average(baseline)
    baseline_std = np.std(baseline)

    zscorer = lambda x: (x-baseline_mean)/baseline_std
    zscore_response = np.array([zscorer(xi) for xi in response])

    return zscore_response

"""
Check if a cell is responsive based on whether the peak of the trial average for any ONE condition type exceed the threshold
@param cell_trace: a single cell's trial activity (the contents of 'traces' in the big dictionary)
@return T/F: true if any one condition type elicited an average peak response with a z-score above threshold
"""
def check_cell_zscore(cell_trace,n_baseline_frames):
    # cell_trace is going to be all the trials of this one cell
    # {freq: intensity: repetition: [x,x,x,x,...]}}}

    for freq in cell_trace:
        for itsy in cell_trace[freq]:

            zscored_trials = []
            for rep in cell_trace[freq][itsy]:
                # convert each trial to a z-score relative to the pre-trial baseline
                zscored_trials.append(get_zscored_response(cell_trace[freq][itsy][rep],n_baseline_frames))

            # convert the matrix of trials into a np array
            zscored_trials_as_np = np.array(zscored_trials)

            # average across all the trials to get a 1 x nFrames vector
            avg_zscored_trial = np.median(zscored_trials_as_np, axis=0)

            # get the peak of the response
            peak_response = np.amax(avg_zscored_trial)

            if (peak_response > ZSCORE_THRESHOLD): # if any single condition type elicited a median peak response above the threshold, we will call the cell active
                return True

    return False
    
"""
Iterate through each cell and check whether it is sound responsive using either the STD method or z-score method
@param cell_dictionary: dictionary of cells with trace activity stored in key "traces" in each cell
@param n_baseline_frames: the number of frames included in the trial epoch that preced the stimulus onset
@return cell_dictionary: same dictionary as was input except with new key 'active' that contains T/F for whether the cell was responsive or not
""" 
def check_all_cells(cell_dictionary,n_baseline_frames):
    for cell in cell_dictionary:
        if (check_cell_zscore(cell_dictionary[cell]['traces'],n_baseline_frames)):
            cell_dictionary[cell]['active'] = True
        else:
            cell_dictionary[cell]['active'] = False

    return cell_dictionary

def main():
    # import our cell dictionary
    # it's formatted like this: 
    # cell { 'traces' { freq { intensity { repetition: [x,x,x,x,...] }}}}
    with open(BASE_PATH + TRACES_FILE, 'rb') as f:
        cell_dictionary = pickle.load(f)

    # define our pre-stim baseline we'll pass into our functions
    n_baseline_frames = round(EPOCH_START_IN_MS/1000 * FRAMERATE) * -1 # these are the frames we'll use as the baseline
    
    traces_with_active_boolean = check_all_cells(cell_dictionary,n_baseline_frames)

    # find the number of active cells
    counter = 0
    for cell in traces_with_active_boolean:
        if traces_with_active_boolean[cell]['active'] == True:
            counter += 1

    print("Number of total cells: ")
    print(len(cell_dictionary))
    print("Number of active cells: ")
    print(counter)

    with open(BASE_PATH+OUTPUT_FILE,'wb') as f:
        pickle.dump(traces_with_active_boolean,f)

if __name__=='__main__':
    main()